川柳ジェネレータ
￣￣￣￣￣￣￣￣

■ コンセプト
　俳句・川柳は 17 文字で表現されるアートだ。
　文字の組合せで表現される世界は膨大である。
　だが、無限ではない。
　
「俳句・川柳」として表現できる言葉の組み合わせは有限であり、番号を通して管理が可能である、と考えることができる。

　世の中に存在しうる「俳句・川柳」に通し番号を割当てる。

　任意の俳句を入力すると、該当する番号を表示する。
　逆に、任意の数値を入力すると、該当する俳句を表示する。

　この世に存在する「俳句・川柳」を自らの管理下に置く、という途方もない（傲慢な？）コンセプトを実現するプロジェクトである。


■ 限界
　「季語」についてはサポートしない。
　それゆえ、本プログラムは「川柳ジェネレータ」と呼称することにする。

　また、漢字には対応しない。
　同音異義語で構成された本来別の俳句・川柳も、本プログラムでは同一のものとして扱う。
（手を抜いた部分。　てへ、ぺろ）


■ アルゴリズム
(0) 基本的な考え方

　17 文字の各文字に、重みを付け、加算することで番号とする。

　各文字が n の値を取り得るとすると、


順番	  16  15  14  13  12      11  10   9   8   7   6   5       4   3   2   1   0
         最後                                                                    最初の文字

		└─┴─┴─┴─┴─┘  └─┴─┴─┴─┴─┴─┴─┘  └─┴─┴─┴─┴─┘  
重み	 n^16    n^14    n^12        n^10     n^8     n^7         n^4     n^2     n^0
             n^15    n^13        n^11     n^9     n^7     n^5         n^3     n^1  ↓
                                                                                    1


(0) 文字の番号
	各文字に番号を振る。
	例えば

	文字	番号
	"　"	0
	"あ"	1
	"い"	2
	"う"	3
	"え"	4
	"お"	5
	"か"	6
	 ：		:
	 ：		:
	"っ"	n-2
	"ん"	n-1

			n_size = n

	表現としては、文字列で表現する。
	拗音など、複数の文字により構成される「文字」もあり得るため。

	濁音・半濁音・拗音・吃音についての詳細は、別途検討する。
	空白も用意する必要があると思われる。

	全文字数が n_size で、配列としては ( n_size - 1) までの添え字が使われる。


(1) 位置
	俳句の中の文字の位置と重みの関係。
	先頭を LSB とする。（上記の図の通り。）
	字足らずは後ろが空白になる。

	uint			ku[17];

	ku[0]			最初の文字（を表現する文字列）
	ku[1]			二番目の文字
	　：			：
	ku[n_size-1]	最後の文字


(2) 文字の切り出し
	入力：文字列配列		input_buff
	出力：文字番号の配列	ku[i]

	char *p = input_buff		p に文字列の先頭を示させる

	i= 0 ～ 16 まで繰り返し
		j= 用意した文字の数だけ繰り返し
			moji[i] と p を moji[i] の長さ分比較。
			不一致なら次の j へ。
			一致したら
				ku[i] として j を記録
				p を moji[i] の長さ分進める
			抜ける
		一致するのがなかったら、エラーで帰る。
	文字列が残っていたらエラー。
	字足らずだったらエラー。


(3) 番号の算出
	get_moji_number( char *str ) : 文字を番号に変換する関数

	char	ku[17];

	number = 0;
	for( i=17-1; i<0; i++ ){
		number = number * n_size + get_moji_number( ku[i] );
	}

	get_moji_number( char str ) は、与えられた文字に対する計算用の数値（ 0～n ）を返す関数。


(4) 番号に対応する俳句の出力

	int	number;					// 番号が入っているとする

★ この部分、もう一度考える。
	number を n_size で割った時の剰余が、その桁の文字に当たる。
	number を n_size で割ったときの商が、次の number になる。

	0 から 16 まで（一文字目から最後の文字まで）、繰り返す

	char	*ku[17];

	for( i=0; i<17; i++ ){
		j = number % n_size;			// n で割った剰余
		number = number / n_size;		// 次の number
		ku[i] = moji[j];
	}

	for( i=0; i<17; i++ ){
		printf( "%s", ku[i] );
	}
	printf( "\n" );


■ 全体フロー
□ メニュー
	動作モード指定
		1 表現から番号検索
		2 番号から表現を検索

□	1 表現から番号検索
 (1) 表現入力
 (2) エラーチェック
 (3) 文字列→番号変換
 (4) 表示（必要に応じてエラーメッセージ）

	エラーチェック：
		文字が少なすぎる
		文字が多すぎる
		「っ」で始まっている
		「っ」が続いている
		「ん」で始まっている

□	2 番号から表現を検索
 (1) 番号入力
 (2) エラーチェック
 (3) 剰余計算、各桁の番号とする
 (3) 各桁の番号を文字化
 (4) 表示

	エラーチェック：
		番号が小さすぎる（字足らず）
		番号が大きすぎる
		「っ」で始まっている
		「っ」が続いている
		「ん」で始まっている

■ 細かいところで注意する必要のあるところ
□ 文字列の型
	全角のひらがなで表示することをめざす。
	char 型ではなく、wchar_t 型で文字を扱う。
	⇒ gcc 環境でトライしたところ、wchar_t 型ではうまく表示できない。
	　 char 型なら処理できたので、こちらで行く。

□ GNU MP
	数値は膨大な値になるため、C 言語の基本的な整数型では扱えない。
	GNU MP を使用する。
	型は mpz_t。

□ Power
	C 言語では演算子にべき乗がないので、アルゴリズムの pow( n, i ) に相当する部分はあらかじめ計算して配列に格納しておく。
	mpz_t	power[17];
	power[0] = 1;
	for( i=1; i<17; i++ ){
		power[i] = power[i-1] * n;
	}
	⇒ これは使わない方法でいく。


■ 実装のためのメモ
	・多精度ライブラリとして GMP を使用する。
		ThinkPad25 の WSL にインストール済み。
		以下のディレクトリにてトライアル実施済み
			/mnt/c/TEMP/Ubuntu/0010_Compile

□ 使い方説明 URL
	https://sehermitage.web.fc2.com/etc/gmp.html
	https://euniclus.com/article/c-language-gmp-big-multiple-long-integer/
	https://gmplib.org/manual/index.html
	https://na-inet.jp/na/gmp-6.1.2_ja.pdf		※ これが一番良さそう


■ 課題
□ 入力バッファの扱いに問題あり。
　繰り返し実行すると、コアダンプする。
　⇒ 直った模様。

□ 表示
　見やすくする。　単位をつける。
　ただし、コピペできるように素の表示も残すこと。

mp_number_max 値	  21	3941	0342	4229	8588	5312	6731	7977	2204	9757
単位					澗		溝		穣		禾予	垓		京		兆		億		万
読み					かん	こう	じょう	じょ	がい	けい


1.18×10^68


万　		まん				１０＾４
億　		おく				１０＾８
兆　		ちょう				１０＾１２
京　		けい				１０＾１６
垓　		がい				１０＾２０
禾予		じょ				１０＾２４
穣　		じょう				１０＾２８
溝　		こう				１０＾３２
澗　		かん				１０＾３６
正　		せい				１０＾４０
載　		さい				１０＾４４
極　		ごく				１０＾４８
恒河沙　	こうがしゃ			１０＾５２
阿僧祇　	あそうぎ			１０＾５６
那由他　	なゆた				１０＾６０
不可思議　	ふかしぎ			１０＾６４
無量大数　	むりょうたいすう	１０＾６８


char	*num_unit[]	= {
	"　",
	"万",
	"億",
	"兆",
	"京",
	"垓",
	"禾予",
	"穣",
	"溝",
	"澗",
	"正",
	"載",
	"極",
	"恒河沙",
	"阿僧祇",
	"那由他",
	"不可思議",
	"無量大数",
};

　言葉で表現。

	・4 桁ずつ区切って何個あるか調べる。⇒ 4 で割った商を計算する。⇒ keta
	・4 桁ずつ区切って最上位が何個あるか調べる⇒ 4 で割った剰余を計算する。len_sub。
		1, 2, 3 のとき、その桁数を表示させる。
		0 のとき、4桁を表示させる。⇒このとき、ループの回数は一つ少なくなるので keta を -1 する。

	繰り返し {
		len_sub 文字を入力文字列から出力文字列にコピー
		出力文字列に '\0' 付加												※ 最初、これがなくて誤動作した。
		配列から該当する番号(keta) の文字列を取り出して出力文字列に連結
		出力文字列ポインタ移動
		入力文字列ポインタ移動
		出力桁数 len_sub を 4 に設定（最初の桁以外は必ず 4）
		keta をデクリメント
	} keta が 0 以上のとき;
