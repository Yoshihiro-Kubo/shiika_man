コーディング資料
￣￣￣￣￣￣￣￣

■ はじめに
　詩歌マネージャのコーディングのために検討した内容を記す。


■ コンセプト
■ できること
■ 限界
　別資料 "0010_コンセプト.txt" を参照のこと。


■ アルゴリズム
(0) 基本的な考え方

　31 文字の各文字に、重みを付け、加算することで番号とする。

　各文字が n の値を取り得るとすると、


順番	  30  29  28  27  26  25  24   …………    4   3   2   1   0
         最後                                                     最初の文字

		└─┴─┴─┴─┴─┴─┴─┘ ………… └─┴─┴─┴─┴─┘
重み	 n^30    n^28    n^26    n^24            n^4     n^2     n^0
             n^29    n^27    n^25                    n^3     n^1  ↓
                                                                   1


(0) 文字の番号
	各文字に番号を振る。
	例えば

	文字	番号
	"　"	0
	"あ"	1
	"い"	2
	"う"	3
	"え"	4
	"お"	5
	"か"	6
	 ：		:
	 ：		:
	"っ"	n-1

			n_size = n

	表現としては、文字列で表現する。
	拗音 "きゃ" のように、複数の文字により構成される「文字」もあり得るため。

	濁音・半濁音・拗音・吃音についての詳細は、別途検討する。
	空白も用意する必要があると思われる。

	全文字数が n_size で、配列としては ( n_size - 1) までの添え字が使われる。


(1) 位置
	俳句の中の文字の位置と重みの関係。
	先頭を LSB とする。（上記の図の通り。）
	字足らずは後ろが空白になる。

	int			ka[31];

	ka[0]			最初の文字（を表現する文字列）
	ka[1]			二番目の文字
	　：			：
	ka[n_size-1]	最後の文字


(2) 文字の切り出し
	入力：文字列配列		input_buff
	出力：文字番号の配列	ka[i]

	char *p = input_buff		p に文字列の先頭を示させる

	i= 0 ～ 31 まで繰り返し
		j= 用意した文字の数だけ繰り返し				※1
			p の中にある moji[j] を探す。
			先頭で一致したら
				ka[i] として j を記録
				p を moji[i] の長さ分進める
				抜ける
			先頭で一致しなかったら
				次の j へ
		一致するのがなかったら、エラーで帰る。
	文字列が残っていたらウォーニング（切り捨てる）。

	入力文字数に応じて分類表示
	17 未満：[俳句・川柳] 字足らず
	17     ：[俳句・川柳]
	18～25 ：[都々逸]字足らず
	26     ：[都々逸]
	27～30 ：[短歌]字足らず
	31     ：[短歌]

※1:
　j は後ろから調べる（ n_size-1 から 0 へ ）
　"きゃ" を "き" より先に検出するため。


(3) 番号の算出
	get_moji_number( char *str ) : 文字を番号に変換する関数

	char	ka[31];

	number = 0;
	for( i=31-1; i<0; i++ ){
		number = number * n_size + get_moji_number( ka[i] );
	}

	get_moji_number( char str ) は、与えられた文字に対する計算用の数値（ 0～n ）を返す関数。


(4) 番号に対応する俳句の出力

	int	number;					// 番号が入っている

	number を n_size で割った時の剰余が、その桁の文字に当たる。
	number を n_size で割ったときの商が、次の number になる。

	0 から 30 まで（一文字目から最後の文字まで）、繰り返す

	char	*ka[31];

	for( i=0; i<31; i++ ){
		j = number % n_size;			// n で割った剰余
		number = number / n_size;		// 次の number
		ka[i] = j;
	}

	出力文字数に応じて分類表示
	17 未満：[俳句・川柳] 字足らず
	17     ：[俳句・川柳]
	18～25 ：[都々逸]字足らず
	26     ：[都々逸]
	27～30 ：[短歌]字足らず
	31     ：[短歌]

	for( i=0; i<31; i++ ){
		printf( "%s", moji[ka[i]] );
	}
	printf( "\n" );


■ 全体フロー
□ メニュー
	動作モード指定
		1 表現から番号検索
		2 番号から表現を検索

□	1 表現から番号検索
 (1) 表現入力
 (2) エラーチェック
 (3) 文字列→番号変換
 (4) 表示（必要に応じてエラーメッセージ）

	エラーチェック：
		文字が少なすぎる
		文字が多すぎる
		「っ」で始まっている
		「っ」が続いている
		「ん」で始まっている

□	2 番号から表現を検索
 (1) 番号入力
 (2) エラーチェック
 (3) 剰余計算、各桁の番号とする
 (3) 各桁の番号を文字化
 (4) 表示

	エラーチェック：
		番号が小さすぎる（字足らず）
		番号が大きすぎる
		「っ」で始まっている
		「っ」が続いている
		「ん」で始まっている

■ 細かいところで注意する必要のあるところ
□ 文字列の型
	全角のひらがなで表示することをめざす。
	char 型ではなく、wchar_t 型で文字を扱う。
	⇒ gcc 環境でトライしたところ、wchar_t 型ではうまく表示できない。
	　 char 型なら処理できたので、こちらで行く。

□ GNU MP
	数値は膨大な値になるため、C 言語の基本的な整数型では扱えない。
	GNU MP を使用する。
	型は mpz_t。

□ Power
	C 言語では演算子にべき乗がないので、アルゴリズムの pow( n, i ) に相当する部分はあらかじめ計算して配列に格納しておく。
	mpz_t	power[17];
	power[0] = 1;
	for( i=1; i<17; i++ ){
		power[i] = power[i-1] * n;
	}
	⇒ これは使わない方法でいく。


■ 実装のためのメモ
	・多精度ライブラリとして GMP を使用する。
		ThinkPad25 の WSL にインストール済み。
		以下のディレクトリにてトライアル実施済み
			/mnt/c/TEMP/Ubuntu/0010_Compile

□ 使い方説明 URL
	https://sehermitage.web.fc2.com/etc/gmp.html
	https://euniclus.com/article/c-language-gmp-big-multiple-long-integer/
	https://gmplib.org/manual/index.html
	https://na-inet.jp/na/gmp-6.1.2_ja.pdf		※ これが一番良さそう


■ 課題
□ 入力バッファの扱いに問題あり。
　繰り返し実行すると、コアダンプする。
　⇒ 直った模様。

□ 表示
　見やすくする。　単位をつける。
　ただし、コピペできるように素の表示も残すこと。

mp_number_max 値		21		3941	0342	4229	8588	5312	6731	7977	2204	9757
単位					澗		溝		穣		𥝱		垓		京		兆		億		万
読み					かん	こう	じょう	じょ	がい	けい


1.18×10^68


万　		まん				１０＾４
億　		おく				１０＾８
兆　		ちょう				１０＾１２
京　		けい				１０＾１６
垓　		がい				１０＾２０
𥝱			じょ				１０＾２４
穣　		じょう				１０＾２８
溝　		こう				１０＾３２
澗　		かん				１０＾３６
正　		せい				１０＾４０
載　		さい				１０＾４４
極　		ごく				１０＾４８
恒河沙　	こうがしゃ			１０＾５２
阿僧祇　	あそうぎ			１０＾５６
那由他　	なゆた				１０＾６０
不可思議　	ふかしぎ			１０＾６４
無量大数　	むりょうたいすう	１０＾６８


char	*num_unit[]	= {
	"　",
	"万",
	"億",
	"兆",
	"京",
	"垓",
	"𥝱",
	"穣",
	"溝",
	"澗",
	"正",
	"載",
	"極",
	"恒河沙",
	"阿僧祇",
	"那由他",
	"不可思議",
	"無量大数",
};

　言葉で表現。

	・4 桁ずつ区切って何個あるか調べる。⇒ 4 で割った商を計算する。⇒ keta
	・4 桁ずつ区切って最上位が何個あるか調べる⇒ 4 で割った剰余を計算する。len_sub。
		1, 2, 3 のとき、その桁数を表示させる。
		0 のとき、4桁を表示させる。⇒このとき、ループの回数は一つ少なくなるので keta を -1 する。

	繰り返し {
		len_sub 文字を入力文字列から出力文字列にコピー
		出力文字列に '\0' 付加												※ 最初、これがなくて誤動作した。
		配列から該当する番号(keta) の文字列を取り出して出力文字列に連結
		出力文字列ポインタ移動
		入力文字列ポインタ移動
		出力桁数 len_sub を 4 に設定（最初の桁以外は必ず 4）
		keta をデクリメント
	} keta が 0 以上のとき;

